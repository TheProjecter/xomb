#summary Reasons why to use an exokernel vs other kernel types.

=Current Trends in OSes=

* Virtualization of EVERYTHING (virtualized storage, virtualized, migratable process containers, scalable multiprocessor code, etc.)
* Hot Sparing and Failover
* ( security / fault / performance ) isolation between processes on the same machine
* continued need to provide performance improvements via OS mechanisms (such as zero-copy network I/O and improved cache management techniques)

= What an OS and Exokernel Do = 

Modern operating systems are said to serve two purposes, resource allocation and abstraction. The goal of the system is to provide a mechanism to enforce a resonable set of policies that a user might desire.
The exokernel is a concept where the kernel provides only a sercure mechanism for division of resources, all other traditional OS tasks are moved into libraries that provide OS functionality to the user application. This allows the greatest possible flexibility in policy choice, because the raw hardware is presented, in a multiplexed fashion, to userspace. The mechanism for enforcement is not allowed to limit the application's policy choices. This has a whole host of advantages related to perfomance (both due to customization and reduced interaction with the kernel) and allows experimentation in new and radical concepts without disrupting the other components of the system.
Aside from these advantages, however, I believe that current OS and VM market trends indicate a demand for a kind of system that an Exokernel is ideally positioned to fill.

= Why the Market Wants an Exokernel =

For years, operating systems such as BSD, Linux and Solaris have been struggling to improve isolation in the system. Chroot and FreeBSD jails have been developed to limit the damage a program can do in case of a security breach. Solaris Containers and Zones, and AIX's WPARs take this concept a step further, isolating processes use of in-kernel data structures. This provides not just security isolation but also fault isolation as even corruption of in-kernel memory is limited to a subset of all active processes. Performance isolation is also provided because policies can be set limiting the percentage of resources a single container can consume, ensuring other containers continue to function at an acceptable level of performance. All of this requires substantion configuration effort on the administrator's part to set sane limits, however.
The many rewrites of the Linux kernel scheduler, in an attempt to balance the needs of interactive and server workloads, is but one example of the difficulty traditional OSes have had, trying to satisfy market demands. Another (longstanding) class of systems, virtual machines, has recently been thrust to the fore with the success of VMware and the advent of Xen. Virtual machines are strong on the the Isolation front, claiming to be as effective as separate hardware at isolation of performance, security and faults. They also mix well with modern trends of storage virtualization and large numbers of CPUs, and allow easy migration of processes and workloads, with a general claim of reducing management complexity for large data centers.
VM users also enjoy the ability to mix applications using different OSes on the same machine. All of this comes at a price, however. Whereas containers duplicated some kernel data structures, now entire OS images are being duplicated including not just in-memory, but also on-disk data. Also, due to the way that the traditional OS running on-top of the VM is kept mostly intact (and separate from the user process), even paravirtualization can only hope to come close to the performance of a native system; virtual machines decrease performance, plain and simple.
VMs can be used to provide hot sparing and failover of applications to handle fatal errors and exceptions. Exokernels provide the same advantages, but due to tighter integration with the client OS, have the added possibility of adding application restart to the error / exception handling chain.
Additionally, the VM, while smaller than a traditional OS, is providing a lot of functionality by virtualizing resources to present a standard interface to the OSes on top. This makes the VM a single point of failure, which cannot be ignored.
So the market wants strong isolation between processes running on the same hardware, low resource overhead and generally improved performance, the ability to mix and match traditional OS functionality, and a neutral or positive impact on management complexity.

Exokernels provide very strong isolation by default. They can provide dramatic improvements on performance by integrating OS functionality into the userspace process via libraries. The resource overhead is low because many data structures can actually be shared between the libOSes and the Exokernel. Libraries can be provided to implement APIs from many different OSes meaning that dynamically linked programs from Windows and Linux, for example, can run side by side once appropriate libOSes are created. By providing standard APIs via libOSes, developers are spared from any added complexity in having raw hardware available to them, but for situations where the provided APIs are insufficent, the developer can build a customized solution for the components that matter to them, which increases their power by orders of magnitude. Overall, management complexity is at risk of increase, as the average application may have its choice of several different libOSes to provide the same API, perhaps a cache manager better suited to databases, or sequential file I/O, a network stack optimized for latency or bandwidth; however, this can be mitigated. By providing sane defaults in addition to hyper-optimized libOSes, "don't care" is preserved as option. Also, an integrated package and libOS manager will allow software mantainers to recommend tweaked libOSes as dependencies, just the way that modern package managers fetch library dependencies. A user or sys-admin is only exposed to the complexity they choose to see, allowing unparalleled control in a system that largely resembles a standard OS (with a very smart linker/loader).
At the very least, when compared to the management of VMs, which requires the building of images and juggling of many copies of OSes, libOS management is more like a problem that admins are already familiar with: library juggling and software installation; the value in exploiting mechanisms already familiar to intermediate `*`nix users cannot be underestimated in terms of learning curve.
In short we feel that Exokernels are better at filling the gaps in traditional OSes that features like jails and containers attempt to solve, and free developers from the constrain of design tradeoffs made by the kernel developers. While VMs are also more successful at meeting administrator goals, in terms of isolation, compared to traditional OSes, they reduce performance and can increase management cost. On the other hand, exokernels can improve performance and present management complexity in terms of the familiar toolchain paradigm. They can also further reduce the kernel's profile as a single point of failure. Ultimately, exokernels can be considered orthogonal to traditional OSes and VMs. We intend to provide a free OS-derived POSIX API and either a Xen or VMware API as some of the first PGOS libOSes in order to make switching easy :)